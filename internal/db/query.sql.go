// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (name, display_name, email,
                      imap_server, imap_port, imap_username, imap_use_ssl, imap_auth_method,
                      smtp_server, smtp_port, smtp_username, smtp_use_tls, smtp_auth_method,
                      refresh_interval_minutes, signature, is_default)
VALUES (?, ?, ?,
        ?, ?, ?, ?, ?,
        ?, ?, ?, ?, ?,
        ?, ?, ?) RETURNING id, name, display_name, email, imap_server, imap_port, imap_username, imap_use_ssl, imap_auth_method, smtp_server, smtp_port, smtp_username, smtp_use_tls, smtp_auth_method, refresh_interval_minutes, signature, is_default, created_at, updated_at
`

type CreateAccountParams struct {
	Name                   string
	DisplayName            string
	Email                  string
	ImapServer             string
	ImapPort               int64
	ImapUsername           string
	ImapUseSsl             bool
	ImapAuthMethod         string
	SmtpServer             string
	SmtpPort               int64
	SmtpUsername           string
	SmtpUseTls             bool
	SmtpAuthMethod         string
	RefreshIntervalMinutes int64
	Signature              sql.NullString
	IsDefault              bool
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.Name,
		arg.DisplayName,
		arg.Email,
		arg.ImapServer,
		arg.ImapPort,
		arg.ImapUsername,
		arg.ImapUseSsl,
		arg.ImapAuthMethod,
		arg.SmtpServer,
		arg.SmtpPort,
		arg.SmtpUsername,
		arg.SmtpUseTls,
		arg.SmtpAuthMethod,
		arg.RefreshIntervalMinutes,
		arg.Signature,
		arg.IsDefault,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Email,
		&i.ImapServer,
		&i.ImapPort,
		&i.ImapUsername,
		&i.ImapUseSsl,
		&i.ImapAuthMethod,
		&i.SmtpServer,
		&i.SmtpPort,
		&i.SmtpUsername,
		&i.SmtpUseTls,
		&i.SmtpAuthMethod,
		&i.RefreshIntervalMinutes,
		&i.Signature,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAttachment = `-- name: CreateAttachment :one
INSERT INTO attachments (email_id, filename, mime_type,
                         size_bytes, content, local_path)
VALUES (?, ?, ?,
        ?, ?, ?) RETURNING id, email_id, filename, mime_type, size_bytes, content, local_path
`

type CreateAttachmentParams struct {
	EmailID   int64
	Filename  string
	MimeType  string
	SizeBytes int64
	Content   []byte
	LocalPath sql.NullString
}

func (q *Queries) CreateAttachment(ctx context.Context, arg CreateAttachmentParams) (Attachment, error) {
	row := q.db.QueryRowContext(ctx, createAttachment,
		arg.EmailID,
		arg.Filename,
		arg.MimeType,
		arg.SizeBytes,
		arg.Content,
		arg.LocalPath,
	)
	var i Attachment
	err := row.Scan(
		&i.ID,
		&i.EmailID,
		&i.Filename,
		&i.MimeType,
		&i.SizeBytes,
		&i.Content,
		&i.LocalPath,
	)
	return i, err
}

const createEmail = `-- name: CreateEmail :one
INSERT INTO emails (uid, thread_id, account_id, folder_id, message_id,
                    from_address, from_name, to_addresses,
                    cc_addresses, bcc_addresses, subject,
                    body_text, body_html, received_date,
                    is_read, is_starred, is_draft)
VALUES (?, ?, ?, ?, ?,
        ?, ?, ?,
        ?, ?, ?,
        ?, ?, ?,
        ?, ?, ?) RETURNING id, uid, thread_id, account_id, folder_id, message_id, from_address, from_name, to_addresses, cc_addresses, bcc_addresses, subject, body_text, body_html, received_date, is_read, is_starred, is_draft
`

type CreateEmailParams struct {
	Uid          int64
	ThreadID     int64
	AccountID    int64
	FolderID     int64
	MessageID    string
	FromAddress  string
	FromName     sql.NullString
	ToAddresses  string
	CcAddresses  sql.NullString
	BccAddresses sql.NullString
	Subject      string
	BodyText     sql.NullString
	BodyHtml     sql.NullString
	ReceivedDate time.Time
	IsRead       bool
	IsStarred    bool
	IsDraft      bool
}

func (q *Queries) CreateEmail(ctx context.Context, arg CreateEmailParams) (Email, error) {
	row := q.db.QueryRowContext(ctx, createEmail,
		arg.Uid,
		arg.ThreadID,
		arg.AccountID,
		arg.FolderID,
		arg.MessageID,
		arg.FromAddress,
		arg.FromName,
		arg.ToAddresses,
		arg.CcAddresses,
		arg.BccAddresses,
		arg.Subject,
		arg.BodyText,
		arg.BodyHtml,
		arg.ReceivedDate,
		arg.IsRead,
		arg.IsStarred,
		arg.IsDraft,
	)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.ThreadID,
		&i.AccountID,
		&i.FolderID,
		&i.MessageID,
		&i.FromAddress,
		&i.FromName,
		&i.ToAddresses,
		&i.CcAddresses,
		&i.BccAddresses,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.ReceivedDate,
		&i.IsRead,
		&i.IsStarred,
		&i.IsDraft,
	)
	return i, err
}

const createFolder = `-- name: CreateFolder :one
INSERT INTO folders (account_id, name)
VALUES (?, ?) RETURNING id, account_id, name
`

type CreateFolderParams struct {
	AccountID int64
	Name      string
}

func (q *Queries) CreateFolder(ctx context.Context, arg CreateFolderParams) (Folder, error) {
	row := q.db.QueryRowContext(ctx, createFolder, arg.AccountID, arg.Name)
	var i Folder
	err := row.Scan(&i.ID, &i.AccountID, &i.Name)
	return i, err
}

const createThread = `-- name: CreateThread :one
INSERT INTO threads (account_id, subject, snippet,
                     is_read, is_starred, has_attachments,
                     message_count, latest_message_date)
VALUES (?, ?, ?,
        ?, ?, ?,
        ?, ?) RETURNING id, account_id, subject, snippet, is_read, is_starred, has_attachments, message_count, latest_message_date
`

type CreateThreadParams struct {
	AccountID         int64
	Subject           string
	Snippet           sql.NullString
	IsRead            bool
	IsStarred         bool
	HasAttachments    bool
	MessageCount      int64
	LatestMessageDate time.Time
}

func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) (Thread, error) {
	row := q.db.QueryRowContext(ctx, createThread,
		arg.AccountID,
		arg.Subject,
		arg.Snippet,
		arg.IsRead,
		arg.IsStarred,
		arg.HasAttachments,
		arg.MessageCount,
		arg.LatestMessageDate,
	)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Subject,
		&i.Snippet,
		&i.IsRead,
		&i.IsStarred,
		&i.HasAttachments,
		&i.MessageCount,
		&i.LatestMessageDate,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE
FROM accounts
WHERE id = ?
`

func (q *Queries) DeleteAccount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAccount, id)
	return err
}

const deleteAttachment = `-- name: DeleteAttachment :exec
DELETE
FROM attachments
WHERE id = ?
`

func (q *Queries) DeleteAttachment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAttachment, id)
	return err
}

const deleteEmail = `-- name: DeleteEmail :exec
DELETE
FROM emails
WHERE id = ?
`

func (q *Queries) DeleteEmail(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEmail, id)
	return err
}

const deleteFolder = `-- name: DeleteFolder :exec
DELETE
FROM folders
WHERE id = ?
`

func (q *Queries) DeleteFolder(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteFolder, id)
	return err
}

const deleteThread = `-- name: DeleteThread :exec
DELETE
FROM threads
WHERE id = ?
`

func (q *Queries) DeleteThread(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteThread, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, name, display_name, email, imap_server, imap_port, imap_username, imap_use_ssl, imap_auth_method, smtp_server, smtp_port, smtp_username, smtp_use_tls, smtp_auth_method, refresh_interval_minutes, signature, is_default, created_at, updated_at
FROM accounts
WHERE id = ? LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, id int64) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Email,
		&i.ImapServer,
		&i.ImapPort,
		&i.ImapUsername,
		&i.ImapUseSsl,
		&i.ImapAuthMethod,
		&i.SmtpServer,
		&i.SmtpPort,
		&i.SmtpUsername,
		&i.SmtpUseTls,
		&i.SmtpAuthMethod,
		&i.RefreshIntervalMinutes,
		&i.Signature,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAttachment = `-- name: GetAttachment :one
SELECT id, email_id, filename, mime_type, size_bytes, content, local_path
FROM attachments
WHERE id = ? LIMIT 1
`

func (q *Queries) GetAttachment(ctx context.Context, id int64) (Attachment, error) {
	row := q.db.QueryRowContext(ctx, getAttachment, id)
	var i Attachment
	err := row.Scan(
		&i.ID,
		&i.EmailID,
		&i.Filename,
		&i.MimeType,
		&i.SizeBytes,
		&i.Content,
		&i.LocalPath,
	)
	return i, err
}

const getDefaultAccount = `-- name: GetDefaultAccount :one
SELECT id, name, display_name, email, imap_server, imap_port, imap_username, imap_use_ssl, imap_auth_method, smtp_server, smtp_port, smtp_username, smtp_use_tls, smtp_auth_method, refresh_interval_minutes, signature, is_default, created_at, updated_at
FROM accounts
WHERE is_default = TRUE LIMIT 1
`

func (q *Queries) GetDefaultAccount(ctx context.Context) (Account, error) {
	row := q.db.QueryRowContext(ctx, getDefaultAccount)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Email,
		&i.ImapServer,
		&i.ImapPort,
		&i.ImapUsername,
		&i.ImapUseSsl,
		&i.ImapAuthMethod,
		&i.SmtpServer,
		&i.SmtpPort,
		&i.SmtpUsername,
		&i.SmtpUseTls,
		&i.SmtpAuthMethod,
		&i.RefreshIntervalMinutes,
		&i.Signature,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmail = `-- name: GetEmail :one
SELECT id, uid, thread_id, account_id, folder_id, message_id, from_address, from_name, to_addresses, cc_addresses, bcc_addresses, subject, body_text, body_html, received_date, is_read, is_starred, is_draft
FROM emails
WHERE id = ? LIMIT 1
`

func (q *Queries) GetEmail(ctx context.Context, id int64) (Email, error) {
	row := q.db.QueryRowContext(ctx, getEmail, id)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.ThreadID,
		&i.AccountID,
		&i.FolderID,
		&i.MessageID,
		&i.FromAddress,
		&i.FromName,
		&i.ToAddresses,
		&i.CcAddresses,
		&i.BccAddresses,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.ReceivedDate,
		&i.IsRead,
		&i.IsStarred,
		&i.IsDraft,
	)
	return i, err
}

const getEmailByMessageID = `-- name: GetEmailByMessageID :one
SELECT thread_id,
       message_id
FROM emails
WHERE message_id = ?
`

type GetEmailByMessageIDRow struct {
	ThreadID  int64
	MessageID string
}

func (q *Queries) GetEmailByMessageID(ctx context.Context, messageID string) (GetEmailByMessageIDRow, error) {
	row := q.db.QueryRowContext(ctx, getEmailByMessageID, messageID)
	var i GetEmailByMessageIDRow
	err := row.Scan(&i.ThreadID, &i.MessageID)
	return i, err
}

const getEmailsStats = `-- name: GetEmailsStats :one
SELECT COUNT(*)                                         as total_emails,
       SUM(CASE WHEN is_read = FALSE THEN 1 ELSE 0 END) as unread_count
FROM emails
WHERE account_id = ?
  AND folder_id = ?
`

type GetEmailsStatsParams struct {
	AccountID int64
	FolderID  int64
}

type GetEmailsStatsRow struct {
	TotalEmails int64
	UnreadCount sql.NullFloat64
}

func (q *Queries) GetEmailsStats(ctx context.Context, arg GetEmailsStatsParams) (GetEmailsStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getEmailsStats, arg.AccountID, arg.FolderID)
	var i GetEmailsStatsRow
	err := row.Scan(&i.TotalEmails, &i.UnreadCount)
	return i, err
}

const getEmailsWithoutBodies = `-- name: GetEmailsWithoutBodies :many
SELECT id, uid, folder_id, subject, from_address, received_date
FROM emails
WHERE account_id = ?
  AND (body_text IS NULL OR body_text = '')
ORDER BY received_date DESC LIMIT ?
`

type GetEmailsWithoutBodiesParams struct {
	AccountID int64
	Limit     int64
}

type GetEmailsWithoutBodiesRow struct {
	ID           int64
	Uid          int64
	FolderID     int64
	Subject      string
	FromAddress  string
	ReceivedDate time.Time
}

func (q *Queries) GetEmailsWithoutBodies(ctx context.Context, arg GetEmailsWithoutBodiesParams) ([]GetEmailsWithoutBodiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmailsWithoutBodies, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmailsWithoutBodiesRow
	for rows.Next() {
		var i GetEmailsWithoutBodiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.FolderID,
			&i.Subject,
			&i.FromAddress,
			&i.ReceivedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFolder = `-- name: GetFolder :one
SELECT id, account_id, name
FROM folders
WHERE id = ? LIMIT 1
`

func (q *Queries) GetFolder(ctx context.Context, id int64) (Folder, error) {
	row := q.db.QueryRowContext(ctx, getFolder, id)
	var i Folder
	err := row.Scan(&i.ID, &i.AccountID, &i.Name)
	return i, err
}

const getFolderByName = `-- name: GetFolderByName :one
SELECT id, account_id, name
FROM folders
WHERE name = ? AND account_id = ?
`

type GetFolderByNameParams struct {
	Name      string
	AccountID int64
}

func (q *Queries) GetFolderByName(ctx context.Context, arg GetFolderByNameParams) (Folder, error) {
	row := q.db.QueryRowContext(ctx, getFolderByName, arg.Name, arg.AccountID)
	var i Folder
	err := row.Scan(&i.ID, &i.AccountID, &i.Name)
	return i, err
}

const getHighestUIDInFolder = `-- name: GetHighestUIDInFolder :one
SELECT uid
FROM emails
WHERE folder_id = ?
ORDER BY uid DESC LIMIT 1
`

func (q *Queries) GetHighestUIDInFolder(ctx context.Context, folderID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getHighestUIDInFolder, folderID)
	var uid int64
	err := row.Scan(&uid)
	return uid, err
}

const getThread = `-- name: GetThread :one
SELECT id, account_id, subject, snippet, is_read, is_starred, has_attachments, message_count, latest_message_date
FROM threads
WHERE id = ? LIMIT 1
`

func (q *Queries) GetThread(ctx context.Context, id int64) (Thread, error) {
	row := q.db.QueryRowContext(ctx, getThread, id)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Subject,
		&i.Snippet,
		&i.IsRead,
		&i.IsStarred,
		&i.HasAttachments,
		&i.MessageCount,
		&i.LatestMessageDate,
	)
	return i, err
}

const getThreadsInFolder = `-- name: GetThreadsInFolder :many
SELECT t.id, t.account_id, t.subject, t.snippet, t.is_read, t.is_starred, t.has_attachments, t.message_count, t.latest_message_date,
       folder_emails.folder_count,
       folder_emails.folder_unread_count,
       folder_emails.latest_folder_sender,
       folder_emails.latest_folder_sender_name
FROM threads t
         INNER JOIN (SELECT e.thread_id,
                            COUNT(*)                                         as folder_count,
                            SUM(CASE WHEN e.is_read = false THEN 1 ELSE 0 END) as folder_unread_count,
                            CAST((SELECT e2.from_address
                                  FROM emails e2
                                  WHERE e2.thread_id = e.thread_id
                                  ORDER BY e2.received_date DESC
                                LIMIT 1) AS TEXT) as latest_folder_sender,
                            CAST((SELECT e2.from_name
                                  FROM emails e2
                                  WHERE e2.thread_id = e.thread_id
                                  ORDER BY e2.received_date DESC
                                LIMIT 1) AS TEXT) as latest_folder_sender_name
                     FROM emails e
                     WHERE e.folder_id = ?
                     GROUP BY e.thread_id
) folder_emails ON t.id = folder_emails.thread_id
WHERE t.account_id = ?
ORDER BY t.latest_message_date DESC
    LIMIT ?
`

type GetThreadsInFolderParams struct {
	FolderID  int64
	AccountID int64
	Limit     int64
}

type GetThreadsInFolderRow struct {
	ID                     int64
	AccountID              int64
	Subject                string
	Snippet                sql.NullString
	IsRead                 bool
	IsStarred              bool
	HasAttachments         bool
	MessageCount           int64
	LatestMessageDate      time.Time
	FolderCount            int64
	FolderUnreadCount      sql.NullFloat64
	LatestFolderSender     string
	LatestFolderSenderName string
}

func (q *Queries) GetThreadsInFolder(ctx context.Context, arg GetThreadsInFolderParams) ([]GetThreadsInFolderRow, error) {
	rows, err := q.db.QueryContext(ctx, getThreadsInFolder, arg.FolderID, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadsInFolderRow
	for rows.Next() {
		var i GetThreadsInFolderRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Subject,
			&i.Snippet,
			&i.IsRead,
			&i.IsStarred,
			&i.HasAttachments,
			&i.MessageCount,
			&i.LatestMessageDate,
			&i.FolderCount,
			&i.FolderUnreadCount,
			&i.LatestFolderSender,
			&i.LatestFolderSenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, name, display_name, email, imap_server, imap_port, imap_username, imap_use_ssl, imap_auth_method, smtp_server, smtp_port, smtp_username, smtp_use_tls, smtp_auth_method, refresh_interval_minutes, signature, is_default, created_at, updated_at
FROM accounts
ORDER BY name
`

func (q *Queries) ListAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, listAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Email,
			&i.ImapServer,
			&i.ImapPort,
			&i.ImapUsername,
			&i.ImapUseSsl,
			&i.ImapAuthMethod,
			&i.SmtpServer,
			&i.SmtpPort,
			&i.SmtpUsername,
			&i.SmtpUseTls,
			&i.SmtpAuthMethod,
			&i.RefreshIntervalMinutes,
			&i.Signature,
			&i.IsDefault,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttachmentsByEmail = `-- name: ListAttachmentsByEmail :many
SELECT id, email_id, filename, mime_type, size_bytes, content, local_path
FROM attachments
WHERE email_id = ?
`

func (q *Queries) ListAttachmentsByEmail(ctx context.Context, emailID int64) ([]Attachment, error) {
	rows, err := q.db.QueryContext(ctx, listAttachmentsByEmail, emailID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.EmailID,
			&i.Filename,
			&i.MimeType,
			&i.SizeBytes,
			&i.Content,
			&i.LocalPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmailsByThread = `-- name: ListEmailsByThread :many
SELECT id, uid, thread_id, account_id, folder_id, message_id, from_address, from_name, to_addresses, cc_addresses, bcc_addresses, subject, body_text, body_html, received_date, is_read, is_starred, is_draft
FROM emails
WHERE thread_id = ?
ORDER BY received_date DESC
`

func (q *Queries) ListEmailsByThread(ctx context.Context, threadID int64) ([]Email, error) {
	rows, err := q.db.QueryContext(ctx, listEmailsByThread, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Email
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.ThreadID,
			&i.AccountID,
			&i.FolderID,
			&i.MessageID,
			&i.FromAddress,
			&i.FromName,
			&i.ToAddresses,
			&i.CcAddresses,
			&i.BccAddresses,
			&i.Subject,
			&i.BodyText,
			&i.BodyHtml,
			&i.ReceivedDate,
			&i.IsRead,
			&i.IsStarred,
			&i.IsDraft,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFolders = `-- name: ListFolders :many
SELECT id, account_id, name
FROM folders
WHERE account_id = ?
ORDER BY name
`

func (q *Queries) ListFolders(ctx context.Context, accountID int64) ([]Folder, error) {
	rows, err := q.db.QueryContext(ctx, listFolders, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Folder
	for rows.Next() {
		var i Folder
		if err := rows.Scan(&i.ID, &i.AccountID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailRead = `-- name: MarkEmailRead :exec
UPDATE emails
SET is_read = TRUE
WHERE id = ?
`

func (q *Queries) MarkEmailRead(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markEmailRead, id)
	return err
}

const markThreadRead = `-- name: MarkThreadRead :exec
UPDATE threads
SET is_read = TRUE
WHERE id = ?
`

func (q *Queries) MarkThreadRead(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markThreadRead, id)
	return err
}

const moveEmail = `-- name: MoveEmail :exec
UPDATE emails
SET folder_id = ?
WHERE id = ?
`

type MoveEmailParams struct {
	FolderID int64
	ID       int64
}

func (q *Queries) MoveEmail(ctx context.Context, arg MoveEmailParams) error {
	_, err := q.db.ExecContext(ctx, moveEmail, arg.FolderID, arg.ID)
	return err
}

const searchEmails = `-- name: SearchEmails :many
SELECT e.id, e.uid, e.thread_id, e.account_id, e.folder_id, e.message_id, e.from_address, e.from_name, e.to_addresses, e.cc_addresses, e.bcc_addresses, e.subject, e.body_text, e.body_html, e.received_date, e.is_read, e.is_starred, e.is_draft
FROM emails e
         JOIN threads t ON e.thread_id = t.id
WHERE (e.subject LIKE '%' || ? || '%'
    OR e.body_text LIKE '%' || ? || '%'
    OR e.from_address LIKE '%' || ? || '%'
    OR e.from_name LIKE '%' || ? || '%')
  AND e.account_id = ?
ORDER BY e.received_date DESC LIMIT ?
OFFSET ?
`

type SearchEmailsParams struct {
	Column1   sql.NullString
	Column2   sql.NullString
	Column3   sql.NullString
	Column4   sql.NullString
	AccountID int64
	Limit     int64
	Offset    int64
}

func (q *Queries) SearchEmails(ctx context.Context, arg SearchEmailsParams) ([]Email, error) {
	rows, err := q.db.QueryContext(ctx, searchEmails,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.AccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Email
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.ThreadID,
			&i.AccountID,
			&i.FolderID,
			&i.MessageID,
			&i.FromAddress,
			&i.FromName,
			&i.ToAddresses,
			&i.CcAddresses,
			&i.BccAddresses,
			&i.Subject,
			&i.BodyText,
			&i.BodyHtml,
			&i.ReceivedDate,
			&i.IsRead,
			&i.IsStarred,
			&i.IsDraft,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleEmailStarred = `-- name: ToggleEmailStarred :one
UPDATE emails
SET is_starred = NOT is_starred
WHERE id = ? RETURNING is_starred
`

func (q *Queries) ToggleEmailStarred(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, toggleEmailStarred, id)
	var is_starred bool
	err := row.Scan(&is_starred)
	return is_starred, err
}

const toggleThreadStarred = `-- name: ToggleThreadStarred :one
UPDATE threads
SET is_starred = NOT is_starred
WHERE id = ? RETURNING is_starred
`

func (q *Queries) ToggleThreadStarred(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, toggleThreadStarred, id)
	var is_starred bool
	err := row.Scan(&is_starred)
	return is_starred, err
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET name                     = ?,
    display_name             = ?,
    email                    = ?,
    imap_server              = ?,
    imap_port                = ?,
    imap_username            = ?,
    imap_use_ssl             = ?,
    imap_auth_method         = ?,
    smtp_server              = ?,
    smtp_port                = ?,
    smtp_username            = ?,
    smtp_use_tls             = ?,
    smtp_auth_method         = ?,
    refresh_interval_minutes = ?,
    signature                = ?,
    is_default               = ?,
    updated_at               = CURRENT_TIMESTAMP
WHERE id = ? RETURNING id, name, display_name, email, imap_server, imap_port, imap_username, imap_use_ssl, imap_auth_method, smtp_server, smtp_port, smtp_username, smtp_use_tls, smtp_auth_method, refresh_interval_minutes, signature, is_default, created_at, updated_at
`

type UpdateAccountParams struct {
	Name                   string
	DisplayName            string
	Email                  string
	ImapServer             string
	ImapPort               int64
	ImapUsername           string
	ImapUseSsl             bool
	ImapAuthMethod         string
	SmtpServer             string
	SmtpPort               int64
	SmtpUsername           string
	SmtpUseTls             bool
	SmtpAuthMethod         string
	RefreshIntervalMinutes int64
	Signature              sql.NullString
	IsDefault              bool
	ID                     int64
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccount,
		arg.Name,
		arg.DisplayName,
		arg.Email,
		arg.ImapServer,
		arg.ImapPort,
		arg.ImapUsername,
		arg.ImapUseSsl,
		arg.ImapAuthMethod,
		arg.SmtpServer,
		arg.SmtpPort,
		arg.SmtpUsername,
		arg.SmtpUseTls,
		arg.SmtpAuthMethod,
		arg.RefreshIntervalMinutes,
		arg.Signature,
		arg.IsDefault,
		arg.ID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Email,
		&i.ImapServer,
		&i.ImapPort,
		&i.ImapUsername,
		&i.ImapUseSsl,
		&i.ImapAuthMethod,
		&i.SmtpServer,
		&i.SmtpPort,
		&i.SmtpUsername,
		&i.SmtpUseTls,
		&i.SmtpAuthMethod,
		&i.RefreshIntervalMinutes,
		&i.Signature,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAttachment = `-- name: UpdateAttachment :one
UPDATE attachments
SET local_path = ?
WHERE id = ? RETURNING id, email_id, filename, mime_type, size_bytes, content, local_path
`

type UpdateAttachmentParams struct {
	LocalPath sql.NullString
	ID        int64
}

func (q *Queries) UpdateAttachment(ctx context.Context, arg UpdateAttachmentParams) (Attachment, error) {
	row := q.db.QueryRowContext(ctx, updateAttachment, arg.LocalPath, arg.ID)
	var i Attachment
	err := row.Scan(
		&i.ID,
		&i.EmailID,
		&i.Filename,
		&i.MimeType,
		&i.SizeBytes,
		&i.Content,
		&i.LocalPath,
	)
	return i, err
}

const updateEmail = `-- name: UpdateEmail :one
UPDATE emails
SET folder_id  = ?,
    is_read    = ?,
    is_starred = ?,
    is_draft   = ?,
    body_text  = ?
WHERE id = ? RETURNING id, uid, thread_id, account_id, folder_id, message_id, from_address, from_name, to_addresses, cc_addresses, bcc_addresses, subject, body_text, body_html, received_date, is_read, is_starred, is_draft
`

type UpdateEmailParams struct {
	FolderID  int64
	IsRead    bool
	IsStarred bool
	IsDraft   bool
	BodyText  sql.NullString
	ID        int64
}

func (q *Queries) UpdateEmail(ctx context.Context, arg UpdateEmailParams) (Email, error) {
	row := q.db.QueryRowContext(ctx, updateEmail,
		arg.FolderID,
		arg.IsRead,
		arg.IsStarred,
		arg.IsDraft,
		arg.BodyText,
		arg.ID,
	)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.ThreadID,
		&i.AccountID,
		&i.FolderID,
		&i.MessageID,
		&i.FromAddress,
		&i.FromName,
		&i.ToAddresses,
		&i.CcAddresses,
		&i.BccAddresses,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.ReceivedDate,
		&i.IsRead,
		&i.IsStarred,
		&i.IsDraft,
	)
	return i, err
}

const updateEmailBody = `-- name: UpdateEmailBody :one
UPDATE emails
SET body_text  = ?
WHERE id = ? RETURNING id, uid, thread_id, account_id, folder_id, message_id, from_address, from_name, to_addresses, cc_addresses, bcc_addresses, subject, body_text, body_html, received_date, is_read, is_starred, is_draft
`

type UpdateEmailBodyParams struct {
	BodyText sql.NullString
	ID       int64
}

func (q *Queries) UpdateEmailBody(ctx context.Context, arg UpdateEmailBodyParams) (Email, error) {
	row := q.db.QueryRowContext(ctx, updateEmailBody, arg.BodyText, arg.ID)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.ThreadID,
		&i.AccountID,
		&i.FolderID,
		&i.MessageID,
		&i.FromAddress,
		&i.FromName,
		&i.ToAddresses,
		&i.CcAddresses,
		&i.BccAddresses,
		&i.Subject,
		&i.BodyText,
		&i.BodyHtml,
		&i.ReceivedDate,
		&i.IsRead,
		&i.IsStarred,
		&i.IsDraft,
	)
	return i, err
}

const updateFolder = `-- name: UpdateFolder :one
UPDATE folders
SET name = ?
WHERE id = ? RETURNING id, account_id, name
`

type UpdateFolderParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateFolder(ctx context.Context, arg UpdateFolderParams) (Folder, error) {
	row := q.db.QueryRowContext(ctx, updateFolder, arg.Name, arg.ID)
	var i Folder
	err := row.Scan(&i.ID, &i.AccountID, &i.Name)
	return i, err
}

const updateThread = `-- name: UpdateThread :one
UPDATE threads
SET subject             = ?,
    snippet             = ?,
    is_read             = ?,
    is_starred          = ?,
    has_attachments     = ?,
    message_count       = ?,
    latest_message_date = ?
WHERE id = ? RETURNING id, account_id, subject, snippet, is_read, is_starred, has_attachments, message_count, latest_message_date
`

type UpdateThreadParams struct {
	Subject           string
	Snippet           sql.NullString
	IsRead            bool
	IsStarred         bool
	HasAttachments    bool
	MessageCount      int64
	LatestMessageDate time.Time
	ID                int64
}

func (q *Queries) UpdateThread(ctx context.Context, arg UpdateThreadParams) (Thread, error) {
	row := q.db.QueryRowContext(ctx, updateThread,
		arg.Subject,
		arg.Snippet,
		arg.IsRead,
		arg.IsStarred,
		arg.HasAttachments,
		arg.MessageCount,
		arg.LatestMessageDate,
		arg.ID,
	)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Subject,
		&i.Snippet,
		&i.IsRead,
		&i.IsStarred,
		&i.HasAttachments,
		&i.MessageCount,
		&i.LatestMessageDate,
	)
	return i, err
}

const updateThreadMessageCount = `-- name: UpdateThreadMessageCount :exec
UPDATE threads
SET message_count = (SELECT COUNT(*)
                     FROM emails
                     WHERE thread_id = threads.id)
WHERE threads.id = ?
`

func (q *Queries) UpdateThreadMessageCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateThreadMessageCount, id)
	return err
}
